\section{Analýza}
\subsection{Operačné systémy}
\indent Informatika a informačné technológie je pomerne mladá vedná disciplína. Jej začiatky je možné datovať od druhej polovice dvadsiateho storočia, čo momentálne predstavuje takmer sedemdesiat rokov. Za tento čas informatika zaznamenala enormný rast vo vývoji hardvéru, ako aj softvéru.  Operačný systém je základná časť akéhokoľvek počítačového sytému, predstavuje softvér, ktorý umožňuje počítačom pracovať. V poslednej dobe, oblasť operačných systémov  prechádza rapídnymi zmenami, pretože počítače sa stali súčasťou každodenného života, a to od malých zariadení, napríklad v automobiloch, až po najsofisitkovanejšie servery nadnárodných spoločností. Aj napriek tomu, že v dnešnej dobe poznáme mnohé operačné systémy, v práci sa zameriame na Windows, Mac OS, Unix a Linux.\cite{osbook}

\subsubsection{Windows}
\indent Microsoft Windows uviedol svoje prvé operačné systémy v novembri roku 1985 ako nadstavbu MS DOS. Jeho popularita rýchlo rástla až vyvrcholila dominantným postavením na trhu v osobných počítačoch. V roku 1993 začal vydávať špecializované operačné systémy, ktoré prinášali novú funkcionalitu pre počítače používané ako servery.\cite{windowsHistory} Pre účely automatizácie sa na Windows serveroch používajú hlavne powershell scripty, písané v rovnomennom jazyku Powershell\cite{winAutomation}.
\paragraph{Podiel na trhu}
\indent Microsoft je aj vzhľadom na svoju históriu najobľúbenejším operačným systémom v segmente osobných počítačov. Podľa webovej stránky statcounter.com\cite{statcounter} a netmarketshare.com\cite{netmarketshare} má 81,73\%  \acrshort{resp.}  88,42\% podiel na trhu.
\newline
\indent Podľa w3techs.com\cite{pop} je serverový operačný systém Windows používaný na 32.0\% počítačoch.
\paragraph{Predinštalovaný softvér}
\indent Windows operačné systémy ponúkajú základný balík nástrojov a programov. Serverové aj neserverové verzie Windowsu ponúkajú  Powershell, ktorý je dostupný od inštalácie.  Oba systémy podporujú aj takzvaný Command prompt alebo príkazový riadok, ktorý je alternatívou k Powershellu. Akékoľvek ďalšie programy je potrebné stiahnuť a doinštalovať.

\subsubsection{MacOs}
\indent  Mac okrem iného ponúka serverovú verziu operačného systému pod názvom OS X Server, ktorý začal písať svoju históriu v roku 2001, avšak neteší sa takej obľube ako Windows, Unix alebo Linux server. OS X server nepoužíva  špecifický skriptovací jazyk, pričom poskytuje možnosť výberu skriptovacieho jazyka, ako napríklad: Python, JavaScript, Perl, AppleScript, Swift alebo Ruby. Každý z uvedených jazykov prináša určité plusy, ako aj mínusy.
\paragraph{Predinštalovaný softvér}
\indent Predinštalovaný softvér pre developerov na Mac OS je Python, AppleScript, Ruby, Bash, BOjective-c. Donedávna bola štandardom aj Java, avšak Apple sa rozhodol pre radikálny krok vylúčiť Javu a propagovať Objective-c.
\paragraph{Podiel na trhu}
\indent Popularita počítačov s predinštalovaným operačným systémom MacOs sa mierne zvyšuje, čo je možné vidieť aj na obrázku na konci sekcie operačných systémov. Podľa webovej stránky statcounter.com\cite{statcounter} a netmarketshare.com\cite{netmarketshare} mu patrí 13,18\% resp.  9,19\% na trhu.
\indent Serverové verzie MacOs podľa stránky w3techs.com\cite{pop} sú na menej ako 0.1\% zariadeniach.
\subsubsection{Unix}
\indent Patrí medzi prvé operačné systémy pre servery, ktorého vývoj začal v roku 1970 a v priebehu rokov vzniklo veľa nových verzií Unixu a Linuxu. V minulosti boli Unixové servery veľmi obľúbené, avšak v súčasnosti sú na ústupe, a to najmä kvôli vyšším obstarávacím a prevádzkovým nákladom. Pre účely Unixu sa vytvoril Unix shell, dostupný v rôznych obmenách, ktorý je často vyhľadávaným jazykom medzi administrátormi a automatizačnými programátormi.
\paragraph{Predinštalovaný softvér}
\indent Na vačšine unixových systémoch je predinštalovaný Shell a Open JDK.
\paragraph{Podiel na trhu}
\indent Podľa stránky w3techs.com\cite{pop} sa Unixové systémy používajú na rovných 68.0\% počítačov.
\subsubsection{Linux}
\indent  Linux je všeobecný názov pre širokú zostavu Linux distribúcií, ktoré používajú Linux Kernel. Linux Kernel bol prvýkrát verejnosti predstavený v roku 1991 a odvtedy bol rozšírený na najviac platforiem. Momentálne je jediným používaným operačným systémom na TOP 500 superpočítačoch (mainframe). Skriptovacím jazykom pre Linux je Unix Shell resp. jeho najrozšírenejšia forma Bash.
\paragraph{Predinštalovaný softvér}
\indent Predinštalovaný softvér vo väčšine distribúciách Linuxu sú Bash, Open JDK - Java, niektoré distribúcie ponúkajú Python. RedHat začína s podporou .NET frameworku.
\paragraph{Podiel na trhu}
\indent Linux je k dispozícii v mnohých formách, tak aby vyhovoval rôznym potrebám, od spotrebiteľsky orientovaných systémov pre domáce použitie až po distribúcie použiteľné v špecifických odvetviach. Podľa webovej stránky statcounter.com\cite{statcounter} a netmarketshare.com\cite{netmarketshare} mu patrí 1,66\% resp.  1,93\%.
Podľa stránky w3techs.com\cite{pop} je operačný systém Linux na 41.0\% počítačoch.
\subsubsection{Porovnanie podielov operačných systémov}
\indent Nasledujúce grafy zobrazujú podiel operačných systémov na trhu v segmente osobných počítačov, ako aj v segmente serverov. Zaujímavý graf je vývoj trendu využívania serverových operačných systémov, z ktorého vidíme, že unixové a linuxové servery zvyšujú svoje podiely na trhu. Naopak, Windows v posledných mesiacoch stratil pár percent. Taktiež je vidieť, že linuxové a unixové systémy pokrývajú viac ako polovicu web stránok, ktoré majú najvyššie hodnotenie. Je potrebné dodať, že percentá na posledných dvoch obrázkoch pre Unix a Linux, nemožeme sčítavať, nakoľko na w3techs berú Linux ako podmnožinu Unix \acrshort{os}. Teda napríklad štatistika z predposledného obrázku hovorí, že podiel Unixu na trhu je 68\% z toho väčšiu časť tvorí práve \acrshort{os} Linux s 41.1\% podielom.
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=\linewidth]{img/statcounter.png}
	\caption{\acrshort{os} - podiel na trhu podľa statcounter\cite{statcounter}}
	\label{fig:test}
	
\end{figure}
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=\linewidth]{img/netmarketshare.png}
	\caption{\acrshort{os} - podiel na trhu podľa netmarketshare\cite{netmarketshare}}
	\label{fig:test}
	
\end{figure}
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=0.4]{img/usg_server.png}
	\caption{Serverové \acrshort{os} - podiel na trhu podľa w3techs\cite{pop}}
	\label{fig:test}
	
\end{figure}
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=0.4]{img/usage_grou_by_os_sites.png}
	\caption{Serverové \acrshort{os} - podiel na trhu a rozdelenie podľa hodnotenia stránok podľa w3techs\cite{pop}}
	\label{fig:test}
	
\end{figure}

\subsection{Programovacie jazyky}
\indent S príchodom osobných počítačov no najmä serverov, sa programátori zaujímali o automatizáciu procesov, ktoré na danom stroji bolo spočiatku potrebné spúšťať manuálne. Nakoľko tieto úlohy neboli na toľko komplexné ako samotné programy, ktoré spúštali bolo vhodné na tieto úlohy využiť/vytvoriť skriptovacie jazyky. V nasledujúcej časti si priblížime zopár programovacích jazykov, ktoré sa v dnešnej dobe bežne používajú na tvorbu automatizovaných skriptov.

\subsubsection{Shell}
\indent
Je skriptovacím jazykom pre unixové distribúcie. Počas rokov prešiel roznymi zmenami a rozšíreniami. Verzie shellu su: sh, csh, ksh,tcsh, bash. Bash sa momentálne teši najväčšej obľube no zsh je verzia shellu, ktorá má najviac rôznych rozšírení funkcionality ako aj veľa priaznivcov medzi developermi. V nasledujúcich častiach všeobecne zhodnotíme jednotlivé výhody resp. nevýhody tohoto skriptovacieho jazyka.

\paragraph{Výhody}
\begin{itemize}
	\item automatizácia často opakujúcich sa úloh
	\item dokáže zbiehať zložité zložené príkazy ako jednoriadkový príkaz  - tzv. reťazenie príkazov
	\item ľahký na používanie
	\item výborné manuálové stránky
	\item ak hovoríme o Unix shelli je portabilný naprieč platformami linuxu-unixu
	\item jednoduché plánovanie automatických úloh
	\newline
\end{itemize}
\paragraph{Nevýhody}
\begin{itemize}
	\item najväčšou nevýhodou je ze natívne nefunguje pod windowsom, existujú iba rôzne emulátory a nástroje tretích strán, ktoré sprostredkujú jeho funkcionalitu,
	\item pomalé vykonávanie príkazov pri porovnaní s inými programovacími jazykmi,
	\item nový proces pre skoro každý spustený príkaz,
	\item zložitejší na pamätanie si rôznych prepínačov, ktoré dané príkazy podporujú,
	\item nejednotnosť prepínočov(hoc to by asi ani nešlo),
	\item neprenosný medzi platformami,
	\item shell nepridáva vlastné príkazy, používa iba tie, ktoré sú dostupné na konkrétnom počítači.
\end{itemize}
\paragraph{Popis a zhodnotenie jazyka}
\indent
Unix Shell je obľúbeným scriptovacím jazykom, vhodným na automatizovanie každodenných operácií. Je jedným z najpoužívanejších skriptovacích jazykou vôbec, nakoľko všetky Linuxové, Unixové servery využívajú práve tento jazyk ako svoj primárny. V nasledujújucich častiach budem popisovať Bash, ktorý je najrozšírenejšia verzia Unix shellu. Zaujímavou vymoženosťou jazyka je pajpa. Pajpa je klasickým príkladom vnútro-procesorovej komunikácie : odovzdáva štandardný výstup "stdout" procesu na štandardný vstup "stdin" iného procesu, viď príklad.
\begin{minted}[]{php}
	zarrelli:~\$ ls -lah | wc -l
	35
\end{minted}
V uvedenom príklade sme vylistovali obsah adresára v ktorom sa práve nachádzame a výstupom z programu sme naplnili štandardný vstup aplikácie "wc" ktorá spočíta, koľko riadkov sa nachádza na vstupe, ktorý jej bol dodaný. Príkaz za znakom pajpy "|" beží v subshelli, čo znamená, že nebude schopný zmodifikovať hodnoty v rodičovskom procese. Zlyhanie príkazu v pajpe vedie k takzvanej "zlomenej pajpe", v tomto prípade exekúcia príkazov skončí. \cite{mbash}
\newpage
Taktiež niektoré často používané príkazy majú pozmenený spôsob zápisu.
Ako príklad si uvedieme príkaz for, pri ktorom bash používa nsledovnú syntax:

\begin{algorithm}
	\begin{minted}{php}
#!/bin/bash
// prvý spôsob zápisu podobná vylepšenej verzii z predchádzajúceho príkladu
for placeholder in list_of_items
do
action_1 \$placeholder
action_2 \$placeholder
action_n \$placeholder
done
//kolekcia vo fore môze byť reprezentovaná vymenovaním prvkov 
//priamo za "in" časťou
for i in 1 2 3 4 5
do
echo "\$i"
done
// c-like prístup
for ((i=20;i > 0;i--))
{
	if (( i % 2 == 0 ))
	then
	echo "\$i is divisible by 2"fi
}
exit 0
	\end{minted} 
	\caption{Bash ukážka rôznych volaní for cyklu. \cite{mbash}}
\label{alg:gen}
\end{algorithm}

Ako je vidieť z príkladu for používa podobnú syntax ako ostatné jazyky, a ešte ju rozširuje, druhý spôsob môže uľahčiť prácu napríklad pri prototypovaní skriptu. Vyššie spomenuté použitia niesú jediné, shell poskytuje možnosť vložiť parametre pre nasledovnú iteráciu priamo z konzoly ako v nasledovnom príklade.
\newpage
\begin{algorithm}
	\begin{minted}{php}
//telo skriptu
#!/bin/bash
i=0
for cities 
do
echo "City $((i++)) is: $cities"
done
exit 0

//následné volanie z konzoly
./for-pair-input.sh 
Belfast Redwood Milan Paris
City 0 is: Belfast
City 1 is: Redwood
City 2 is: Milan
City 3 is: Paris
	\end{minted}
	\caption{Bash ukážka volania skriptu s for cylom priamo z konzoly . \cite{mbash}}
	\label{alg:gen}
\end{algorithm}

Avšak syntax jazyka sa učí tažšie nakoľko používa rôzne prepínače, ktoré novému používateľovi nemusia byť sprvu jasné. 
V tabuľke uvádzame príklad prepínačov pre if, ktorý pre podmienkovú časť používa hranaté zátvorky namiesto okrúhlych na aké sme zvyknutý z väčšiny programovacích jazykov. Za zmienku stojí tiež, že napríklad Unix shell nepoužíva žiadne zátvorky v podmienkovej časti príkazu, na ukončenie podmienkovej časti sa používa bodkočiarka, čo spôsobuje problémi pri prenositeľnosti. If ponúka aj ďalšie prepínače no zhodnotili sme, že pre ilustráciu budú postačovať aj príklady uveené v tabuľke.
Najvačsia nevýhoda je, že ani shell script nieje jazyk, ktorý by bol multiplatformový a teda ak by sme mali prostredie, kde servery bežia na rôznych operačných systémoch, potrebujeme poznať ďalší jazyk, ktorým docielime rovnaké alebo aspoň podobné výsledky.
\newline
\begin{table}[h!]
	\centering
	\begin{tabular}{|p{4cm}|p{13cm}|}
		\hline
		Reťazcové porovnanie & Popis \\
		\hline
		Str1 = Str2	& Vráti true ak sa porovnávané reťazce rovnajú. \\ 
		\hline
		Str1 != Str2 &	Vráti true ak porovnávané reťazce nie sú rovnaké.\\ 
		\hline
		-n Str1	 &R Vráti true ak reťazec nie je null resp. o dĺžke 0.\\ 
		\hline
		-z Str1	& Returns true ak reťazec je null resp. o dĺžke 0.\\
		\hline
	\end{tabular}
\caption{Ukážka reťazcových prepínačov v podmienkovom výraze if \cite{shellprep}}
\label{table:1}

\end{table}
		\begin{table}[h!]
			\centering
			\begin{tabular}{|p{4cm}|p{13cm}|}
		\hline
		Numerické porovnanie	& Popis \\
		\hline
		expr1 -eq expr2	& Vráti true ak sú porovnávané výrazy rovné. \\
		\hline
		expr1 -ne expr2	& Vráti true if ak nie sú porovnávané výrazy rovné. \\
		\hline
		expr1 -gt expr2	& Vráti true ak je hodnota premmenej expr1 väčšia než hodnota premennej expr2. \\
		\hline
		expr1 -ge expr2	& Vráti true ak je hodnota premmenej expr1 väčšia alebo rovná hodnote premennej expr2. \\
		\hline
		expr1 -lt expr2	& Vráti true ak je hodnota premmenej expr1 menšia než hodnota premennej  expr2. \\
		\hline
		expr1 -le expr2	& Vráti true ak je hodnota premmenej expr1 menšia alebo rovná hodnote premennej expr2. \\
		\hline
		! expr1	& Operátor "!" zneguje hodnotu premennej expr1. \\
		\hline
	\end{tabular}
	\caption{Ukážka numerických prepínačov v podmienkovom výraze if \cite{shellprep}}
	\label{table:1}
	
\end{table}
\newpage

\subsubsection{Powershel/Classic command line}
\indent  
Command line je základným skriptovacím jazykom pre windows distribúcie, ktorý poskytuje malé API  pre svojich používateľov. Aj kôli tomu Miscrosoft prišiel s novým jazykom Powershell. Powershell je kombináciou príkazového riadku, funkcionálneho programovania a objektovo orentovaného programovania. Je založený na .NET frameworku, ktorý mu dáva istú mieru flexibility. 
Jeho výhody a nevýhody si popíšeme v nasledujujúcich častiach.

\paragraph{Výhody}
\begin{itemize}
	\item bohaté api
	\item výborne riešený run-time 
	\item flexibilný
	\item veľmi jednoduché prepnúť z .NET frameworku
	\item dokáže pridávať funkcionalitu používaním tired a funkcií z .NET knižníc
	\newline 
\end{itemize}
\paragraph{Nevýhody}
\begin{itemize}
	\item bohaté api - nejednoznačné, kedy čo použiť
	\item niektoré výhody jazyka sú až nevhodne skryté pred používateľmi
	\item staršie verzie serverov nie sú Powershell-om podporované ako novšie
	\item dokumentácia je horšia ako v prípade Shell scriptu
	\newline
\end{itemize}

\paragraph{Popis a zhodnotenie jazyka}
Powershell je obľúbený medzi programátormi a administrátormi, ktorý pracujú pod operačným systémom Windowsu. Do nedávna kým Pewrshell bežal na .NET frameworku ho nebolo možné používať mimo operačných systémov Windows, avšak s príchodom frameworku .NET Core sa situácia zmenila. Tento frawework je momentálne open source, jeho zdrojové kódy boli zverejnené a je doň možné prispievať. Okrem iného podporuje rovnaké alebo aspoň podobné štruktúry ako Shell script a poskytuje v niektorých prípadoch rovnaké príkazy ako napríklad : mv, cp, rm, ls. Jednen zo zásadných rozdielov medzi Shellom a Powrshellom je ten, že kým v Shelli sú pre vstup aj výstup používané textové reťazce, ktoré je potrebné rozparsovať a interpretovať v Powershelli je všetko presúvané ako objekt. Ide o najzásadnejší rozdiel, nakoľko ostatné veci boli zrejme navrhované v spolupráci s používateľmi Shell scriptu. \cite{psbook}

Pre demonštráciu rozdielov pri odovzdávaní si parametrov medzi príkazmi prikladám nasledovný príklad.
\newpage
\begin{algorithm}
	\begin{minted}[]{php}
	function changeName(\$myObject)
	{
		if (\$myObject.GetType() -eq [MyType])
		{
			//vypíš obsah premennej
			\$myObject.Name
			//zmeň reťazec pre atribút name
			\$myObject.Name = "NewName"
		}
		return \$myObject
	}
	
	// Vytvorenie objektu s argumentom OriginalName a následné použitie funkcie na zmenu argumentu
	//PS> \$myObject = New-Object MyType -arg "OriginalName"
	//PS> \$myObject = changeName \$myNewObject
	//OriginalName
	//PS> \$myObject.Name
	//NewName
	// Ukážka s využitím pipe
	//PS> \$myObject = New-Object MyType -arg "OriginalName" | changeName
	//OriginalName
	//PS> \$myObject.Name
	//NewName
	\end{minted}
	\caption{Ukážka použitia pipe v powershell. \cite{netalg}}
	\label{alg:gen}
\end{algorithm}

\subsubsection{Python}
\indent Do analýzy sme sa rozhodli pripojiť aj Python. Python sme si nevybrali náhodne, nakoľko je jedným z najpopulárnejších programovacích jazykov súčastnosti. Je viacúčelový, patrí mezi vyššie programovacie jazyky, objektovo orientovaný, interaktívny, interpretovaný a extrémne používateľsky prijateľný.\cite{python}
\paragraph{Výhody}
\begin{itemize}
	\item Je ľahko čitateľný, tým pádom ľahšie pochopiteľný
	\item Syntax orientovaná na produktivitu
	\item Multiplatformový - po inštalácii interpretera
	\item Množstvo rôznych knižníc
	\item Open source
	\newline
\end{itemize}
\paragraph{Nevýhody}
\begin{itemize}
	\item Rýchlosť
	\item Slabšia dokumentácia
	\item Nevhodný pre úlohy pracujúce s vyšším množstvom pamäte
	\item Nevhodný pre viac-procesorovú prácu
	\item Nevhodný pre vývoj na mobilných zariadeniach
	\item Limitácie pri prístupe k databázam 
	\newline
\end{itemize}

\paragraph{Popis a zhodnotenie jazyka}
\indent Ako sme spomínali Python je jeden z najobľúbenejších jazykov súčastnosti, veľkú časť tejto komunity tvoria vedci, ktorý nemajú rozsiahle programátorské znalosti. Práve jednoduchosť, čitateľnosť a pochopiteľnosť jazyka sa nemalou mierou podieľajú na tomto fakte. Taktiež tu nieje nutné manažovať pamäť a iné netriviálne záležitosti ničších programovacích jazykov. Jazyk je síce objektovo orientovaný no jednoducho sa v ňom píšu aj skripty.  Jazyk poskytuje štruktúry ako pajpa, dokážeme v ňom jednoducho pracovať s procesmi, vytvárať triedy, inštancie, jednoducho prototypovať a odsymulovať rôzne problémy. Veľkou výhodou tohoto jazyka je, že je open source s veľkou komunitou, ktorá rada testuje nové vydania, nahlasujú problímy a tým pádom sa jazyk rýchlejšie a kvalitnejšie vyvíja. Na Pythone vznikli zaujímave webové framworky ako napríklad Django. Každá strana má dve mince a ani Python nie je stopercentný. Tým, že je to interpretovaný jazyk neprekypuje rýchlosťou. Veľa ľudí sa zaoberá rýchlosťou jazykov, zisťujú efektívnosť pri rôznych úkonoch ako napríklad cykly, volania funkcií, aritmetika, prístup k pamäti, vytváranie objektov. V nasledujúcich tabuľkách je vidno rozdiel v rýchlosti jednotlivých testov. 
\begin{center}
	\begin{table}[htbp]
		\begin{tabular}{|p{2.5cm}|p{2.5cm}|p{2.5cm}|p{2.5cm}|}
			\hline
			\textbf{Jazyk} & \textbf{Force field benchmark}  & \textbf{Array reverse benchmark}&\textbf{Rolling average benchmark} \\ 
			\hline
			C++ (-O2)&1.892&4.367&0.005\\
			\hline
			Java 7&2.469&3.776&0.463\\
			\hline
			C\# (normal)&10.712&14.071&0.621\\
			\hline
			JavaScript&16.159&13.162&1.312\\
			\hline
			Python 2&717.2&1485&71.550\\
			\hline
			Python 3&880.7&1466&81.143\\
			\hline
		\end{tabular}
		\caption{Porovnanie rýchlostí rôznych jazykov\cite{gitspeed}}
		\label{table:1}
	\end{table}
\end{center}
Aj keď sme spomenuli viaceré nedostatky, asi najväčším je rýchlosť. Nvm čo ďalej. 
\subsection{Existujúce riešenia}
\indent
Existuje množstvo emulátorov a nástrojov tretích strán, ktoré sprostredkúvajú funkcionality shell scriptu do Windowsu, nikeotré z nich si predstavíme.

\subsubsection{ConEmu}
\indent ConEmu je konzolový emulátor, ktorý poskytuje jednoduché GUI do ktorého je možné vložiť viacero konzol. Dokáže spúšťať jednoduché GUI aplikácie ako napríklad Putty, Cygwin. Poskytuje množstvo nastavení ako nastavenie kurzora, priehľadnosti, písma a pod. Podporuje Windows 2000 a neskoršie verzie. Neposkytuje verziu pre ine operačné systémy. \cite{conemu}
\paragraph{Skúsenosti}
\indent ConEmu je podarený emulátor, ktorý je schopný vykonávať akýkoľvek skript. Používaním sme neprišli na závažné nedostatky, ktoré by neboli popísane v ich issues logu na githube. Ale ako každý softvér je aj ConEmu náchylný na chyby. Podla ich issues logu sa do ich oficiálnych releasov dostávajú rôzne problémy, ktoré neboli problémom v predchadzajúcich verziách. V tomto prípade je na zvážení každého či problémy, ktoré sa môžu dostávať do jednotlivých verzií emulátora stoja za jeho použitie, resp. či jeho kladné stránky sú natoľko dobré aby prevýšili zápory.

\begin{figure}[!htbp]
\centering
\includegraphics[scale=0.3]{img/conEmuImg.jpg}
\caption{Ukážka ConEmu emulátora}
\label{fig:test}
\end{figure}
\newpage
\subsubsection{cmder}
\indent Cmder je ďalším príkladom emulátora shell terminálu. Vychádza z troch projektov ConEmu, Clink a Git pre Windows - voľiteľná súčasť. ConEmu sme si predstavili v predcházajúcej časti s jeho kladymi a zápormi. Clink, konkrétne clink-completions je v projekte využívaný na zvýšenie komfortu pri písaní skriptov, nepridáva ďalšiu shellovú funkcionalitu. \cite{cmder}
\paragraph{Skúsenosti}
\indent ConEmu je príjemný nástroj, dokáže zjednodušíť človeku prácu obzvlášť ak je zvyknutý na programovanie v shell scripte. Nakoľko cmder používa ConEmu ako emulátor shell terminálu a je úzko určený pre Windows platformu nemožno hovoriť o multiplatformovom riešení.
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=0.3]{img/cmder.jpg}
	\caption{Ukážka cmder emulátora}
	\label{fig:test}
\end{figure}
\newpage
\subsubsection{Babun}
\indent Babun je ďalším z množstva emulátorov pre Windows, ktorý je nadstavbou cygwinu. Vo svojom jadre používa zshell a bash, ktoré sme popísali ako populárne medzi komunitou. Prináľa vlasné gui, ktoré dokáže zafarbovať text podla zdrojoveho jazyka, čo zvyšuje prehľadnosť. Obsahuje git, svn, puython, perl. Tiež má integrované sťahovanie nových packagov, ktoré ponúka cygwin pomocou kľúčového slova pact. Prenositeľnosť skriptov z unixových strojov je zabezpečená tým, že používa bash a zsh, avšak je to emulátor čisto pre Windows distribúcie.\cite{babun}
\begin{figure}[!htbp]
	\centering
	\includegraphics[scale=0.4]{img/babun.jpeg}
	\caption{Ukážka babun emulátora}
	\label{fig:test}
\end{figure}
\subsubsection{MobaXterm}
\indent Poskytuje množstvo funkcionality avšak je zatažený licenciou v hodnote 50 eur. \cite{mobaxterm}
\paragraph{Neplatená verzia}
\begin{itemize}
	\item Plná podpora SSH a X serveru
	\item Vzdialená plocha (RDP, VNC, Xdmcp)
	\item Vzdialený terminál (SSH, telnet, rlogin, Mosh)
	\item X11-Forwarding
	\item Automatický SFTP prehliadač
	\item Podpora pluginovt
	\item Možnosť inšalačnej alebo prenositeľnej verzie
	\item Plná dokumentácia
	\item Maximálne 12 spojení
	\item Maximálne 2 SSH tunely
	\item Maximálne 4 maká
	\item Maximálne 360 sekúnd pre Tftp, Nfs a Cron
\end{itemize}

\paragraph{Platená verzia}

\begin{itemize}
	\item Všetky vymoženosti z neplatenej verzie Home Edition +
	\item Možnosť upraviť svoju uvítaciu správu a logo
	\item Modifikovať profilový skript
	\item Odstrániť nechcené hry, šetriče obrazovky alebo nástroje
	\item Nelimitovaný počet spojení
	\item Nelimitovaný počet tunelov a makier
	\item Nelimitovaný čas behu pre sieťové daemony
	\item Podpora centrálneho hesla
	\item Profesionálny support
	\item Doživotné právo používania
\end{itemize}

\subsection{Zhodnotenie analyzovaných technológií}
\indent Analýza ukázala, že väčšinový podiel na trhu osobných počítačov ako aj serverov si delia medzi sebou Unix/Linux a Windows operačné systémy. Preto sme si analyzovali hlavne programovacie jazyky, ktoré sú obľúbené administrátormi daných jazykov. Tiež sme prešli rôzne dostupné riešenia problému univerzálnej konzoly, avšak ani jeden z produktov neposkytoval kompatibilitu na oboch alebo viacerých systémoch, nanjvyš kopíroval funkcie jedného systému do druhého. Na základe týchto poznatkov, ako aj poznatkov podrobnejšie rozpísaných v predchádzajúcich častiach sme sa rozhodli pokračovať v analýze prekladu jazykov a získané vedomosti pretaviť do vlastného univerzálneho platformovo nezávislého konzolového riešenia.

\section{Preklad jazykov}
\indent Pri programovacích jazykoch nás zaujímajú ich vyjadrovacie schopnosti ako aj vlastnosti z hľadiska ich rozpoznania. Tieto vlasnosti sa týkajú programovania a prekladu, pričom obe je potrebné zohľadniť pri tvorbe jazyka. V dnešnej dobe sa používajú na programovanie hlavne takzvané vyššie programovacie jazyky, môžeme ich označiť ako zdrojové jazyky. Na to aby vykonávali čo používateľ naprogramoval je potrebné aby boli pretransformované do jazyka daného stroja. Spomínanú transformáciu zabezpečuje prekladač, prekladačom máme na mysli program, ktorý číta zdrojový jazyk a transformuje ho do cieľového jazyka, ktorému rozumie stroj.\cite{gram}

\subsection{Kompilátor proces prekladu}
Aby bol preklad možný, musí byť zdrojový kód programu napísaný podľa určitých pravidiel, ktoré vyplývajú z jazyka. Proces prekladu je možné rodeliť na 4 hlavné časti.
\begin{itemize}
	\item lexikálna analýza
	\item syntakticka analýza
	\item spracovanie sémantiky
	\item generovanie cieľového jazyka
\end{itemize}
\indent Podrobnejšie si stručne popíšeme všetky štyri časti, ktoré majú pre nás z hľadiska prekladu najväčší zmysel.
\newline
\subsubsection{Lexikálna analýza}
	\indent Lexikálna analýza je prvou fázou kompilátora. Dopredu napísaný zdojový kód je postupne spracovávaný preprocesorom, ktorý vytvára takzvané lexémy. 
	 \newline Lexémou nazývame postupnosť alfanumerických znakov. Tieto postupnosti znakov sú následne vkladané do lexikálneho analyzátora, ktorý ma za úlohu vytvoriť zo vstupných lexém tokeny slúžiace ako vstup pre syntaktický analyzátor. 
	 \newline Tokeny sa vytvárajú na základe preddefinovaných pravidiel, ktoré sa v programovacích jazykoch definujú ako pattern. V prípade, že lexikálny analyátor nieje schopný nájsť  pattern pred danú lexému musí vyhlásiť chybu počas tokenizácie.  
	 \newline Výstupom z lexikálnej analýzy sú takzvané tokeny, ktoré tvoria vyššie jednotky jazyka ako kľúčové slová jazyka, konštanty, identifikátory, operátory a iné.\cite{gram}
	 
	 \begin{figure}[!htbp]
	 	\centering
	 	\includegraphics[width=15cm]{img/lexical_analysis.jpg}
	 	\caption{Ukážka práce lexikálneho analyzátora}
	 	\label{fig:test}
	 \end{figure}
 \newline
 
\subsubsection{Syntaktická analýza}
\indent Ďalšou fázou je syntaktická analýza. Úlohou Syntaktického analyzátora je kontrola správnosti vytvorených tokenov s uchovaním niektorých získaných informácií o štruktúre skúmanej syntaktickej jednotky. Syntaktická analýza sa radí medzi bezkontextové gramatiky. Po skoncení syntaktickej analýzy prichádza na rad sémantická analýza.\cite{gram}

 \newline
  \newline
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=15cm]{img/syntax_analyzer.jpg}
	\caption{Ukážka práce syntaktickeho  analyzátora}
	\label{fig:test}
\end{figure}
 \newline
 \newpage
\subsubsection{Limitácia syntaktickej analýzy}
\indent Syntaktický analyzátor ziska vstup z tokenu, ktorý vytvorí lexikálny analyzátor. Lexikálne analyzátory sú zodpovedné za validitu tokenu.Syntaktické analyzátory majú nasledovné limitácie.

\begin{itemize}
	\item nedokážu zistiť validitu tokenu
	\item nedokážu zistiť či je token používaný pred tým ako je deklarovaný
	\item nedokážu zistiť či je token používaný pred tým ako je inicializovaný
	\item nedokážu zistiť validitu operácie, ktorú token vykonáva
\end{itemize}



\subsubsection{Semantická  analýza}
\indent Sémantická analýza má za úlohu interpretovať symboly, typy, ich vzťahy.Sémantická analýza rohoduje či má syntax programy význam alebo nie.
Ako príklad zisťovania významu môžeme uviesť jednoduchú inicializáciu premennej.\cite{gram}

\begin{lstlisting}

	int integerVariable = 6

	int secondIntegerVariable = "six"
\end{lstlisting}

Oba príklady by mali prejsť cez lexikálnu a syntaktickú analýzu. Je až na sémantickej analýze aby rozhodla o správnosti zápisu programu a v prípade nesprávneho zápisu informovala o chybe.  Hlavné úlohy sémantickej analýzy sú" :

\begin{itemize}
	\item zisťovanie dosahu definovaných tokenov takzvaný scoping
	\item kontrola typov
	\item deklaracia premenných
	\item definícia premenných
	\item viacnásobná deklarácia premenných v jedno scope
\end{itemize}

\subsubsection{Generovanie cieľového jazyka}
\indent Generovanie cieľového jazyka môžeme považovať za poslednú fázu kompilátora. V tejto fáze sa preklápa jazyk z vyššieho jazyka do strojového jazyka, ktorý úspešne prešiel cez analyzačné časti .\cite{gram}

\section{Návrh riešenia}
\subsection{Prípady použitia}
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=\linewidth]{img/usecase.jpg}
	\caption{Prípady použitia pre navrhovanú aplikáciu}
	\label{fig:test}
\end{figure}
\newpage
\subsection{Popis prípadov použitia}
\indent V tejto časti sa venujeme popisu jednotlivých prípadov použitia. Diagram prípadov použitia spolu s popisom sú základnými prvkami, na ktorých je možné špecifikovať novovznikajúci softvér. Je dôležité najpodstatnejšie časti systému špecifikovať na začiatku, aby pri navrhovaní aplikácie mohli byť prijaté rozhodnutia zaručujúce dosiahnutie najlepšieho výsledného riešenia vyhovujúceho špecifikácii. Ako je zjavné aj z priloženého diagramu prípadov použitia, pre aplikáciu sme identifikovali dvoch hráčov : Vývojár skriptov a Vývojár balíčkov. Títo hráči majú jednu spoločnú črtu - pre obe platí, že hráč je vývojár. Avšak je rozdiel medzi vývojárom skriptu a vývojárom balíčkov(nových súčastí systému), čo môžeme vyčítať z popisu konkrétnych prípadov použitia.
\subsubsection{Vývojár skriptov}
\indent Rola sa zameriava hlavne na používanie hotovej aplikácie, prácu s balíčkami, vytváranie skriptov, efektívne využívanie dostupného \acrshort{api}. 
\paragraph{Spustiť konzolu}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		\hline
		\textbf{Use case} & Spustiť konzolu \\ 
		\hline
		\textbf{Podmienky} & Používateľ musí disponovať stiahnutou aplikáciou.\\
		\hline
		\textbf{Vstup} & Nie je potrebný žiadny vstup od používateľa.\\
		\hline
		\textbf{Popis} & Konzolové rozhranie sa spustí. \\ 
		\hline
		\textbf{Výstup} & Konzola zobrazí základné údaje o konfigurácii.\\
		\hline
		\textbf{Chyba} & Konzola sa nespustí, musí však poskytnúť informáciu o chybe ktorá pri štarte nastala.\\
		\hline
	\caption{Use case : Spustiť konzolu}
	\label{table:1}
	\end{longtable}
\end{center}

\paragraph{Spustiť príkaz}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		\hline
		\textbf{Use case} & Spustiť príkaz \\ 
		\hline
		\textbf{Podmienky} & Shell aplikácia musí byť spustená. \\ 
		\hline
		\textbf{Vstup} & Textový reťazec obsahujúci príkaz a jeho argumenty.\\
		\hline
		\textbf{Popis} & Používateľ zadá platný príkaz, následne získa výstup pre zadaný príkaz. \\ 
		\hline
		\textbf{Výstup} & Textový reťazec, ktorý sa v závislosti od programu mení v dĺžke a obsahu.\\
		\hline
		\textbf{Chyba} & V prípade zlyhania je používateľ informovaný o probléme, ktorý nastal.\\
		\hline
		\caption{Use case : Spustiť príkaz}
		\label{table:1}
	\end{longtable}
	
\end{center}
\paragraph{Spustiť skript}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		\hline
		\textbf{Use case} & Spustiť skript \\ 
		\hline
		\textbf{Podmienky} & Shell aplikácia musí byť spustená a skript správne napísaný.\\ 
		\hline
		\textbf{Vstup} & Vstupom je skript, definujúci v hlavičke balíčky ktoré bude používať. Za nimi môže nasledovať čokoľvek od definície premenných, funkcií. V tele skriptu musí byť zadefinovaná metóda main(String args).\\
		\hline
		\textbf{Popis} & Vykonajú sa všetky príkazy tak, ako sú napísané v zdrojovom súbore. \\ 
		\hline
		\textbf{Výstup} & Výstup je textový reťazec, závislý na logike skriptu.\\
		\hline
		\textbf{Chyba} & V prípade chyby pri sťahovaní závislostí, exekúcie príkazov alebo iných komplikácií počas behu, program zapisuje na štandardný chybový výstup chybové hlášky spolu so základným popisom problému, tracom.\\
		\hline
		\caption{Use case : Spustiť skript}
		\label{table:1}
	\end{longtable}

\end{center}

\paragraph{Spustiť Shell príkaz}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}

			\hline
			\textbf{Use case} & Spustiť Shell príkaz \\ 
			\hline
			\textbf{Podmienky} & Shell aplikácia musí byť spustená a skript správne napísaný. Taktiež musí byť v operačnom systéme ktorý podporuje Shell. \\ 
			\hline
			\textbf{Vstup} & Textový reťazec obsahujúci príkaz a jeho argumenty.\\
			\hline
			\textbf{Popis} & Používateľ zadá platný príkaz, následne získa výstup pre zadaný príkaz. \\ 
			\hline
			\textbf{Výstup} &Textový reťazec, ktorý sa v závislosti od programu mení v dĺžke a obsahu. \\
			\hline
			\textbf{Chyba} & V prípade zlyhania je používateľovi vratený chybový kód.\\
			\hline
		\caption{Use case : Spustiť shell príkaz}
	\label{table:1}
	
	\end{longtable}
\end{center}

\paragraph{Spustiť commander príkaz}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}

			\hline
			\textbf{Use case} & Spustiť commander príkaz \\ 
			\hline
			\textbf{Podmienky} & Shell aplikácia musí byť spustená a skript správne napísaný. Systém musí mať nainštalovaný Windows commander.\\ 
			\hline
			\textbf{Vstup} & Textový reťazec obsahujúci príkaz a jeho argumenty.\\
			\hline
			\textbf{Popis} & Používateľ zadá platný príkaz začinajúci win alebo ext, následne získa výstup pre zadaný príkaz. \\ 
			\hline
			\textbf{Výstup} &Textový reťazec, ktorý sa v závislosti od programu mení v dĺžke a obsahu. \\
			\hline
			\textbf{Chyba} & V prípade zlyhania je používateľovi vratený chybový výstup z príkazového riadku.\\
			\hline
	\caption{Use case : Spustiť powershell príkaz}
	\label{table:1}

	\end{longtable}
\end{center}
\paragraph{Reťazenie príkazov}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}

			\hline
			\textbf{Use case} & Reťazenie príkazov \\ 
			\hline
			\textbf{Podmienky} & Shell aplikácia musí byť spustená. Vstup musí byť zadaný v správnom formáte.\\ 
			\hline
			\textbf{Vstup} & Textový reťazec obsahujúci sekvenciu príkazov, ich argumenty spojené znakom pajpy "|".\\
			\hline
			\textbf{Popis} & Systém rozozná, že ide o zreťazený príkaz a následne začne vykonávať príkazy v poradí v akom boli zadané. Jednotlivé príkazy odovzdajú  výstupy nasledovníkovi po úspešnom ukončení. Príkazy sa vykonávajú dovtedy, pokým nepríde na posledný príkaz v sekvencii, alebo ak počas behu nastane chyba. O chybe je používateľ oboznámený a chyba je zapísaná na štandardný chybový výstup. \\ 
			\hline

			\textbf{Výstup} & Textový reťazec, ktorý sa v závislosti od programu mení v dĺžke a obsahu, výstup bude vygenerovaný posledným príkazom sekvencie.\\
			\hline

			\textbf{Chyba} & O chybe je používateľ oboznámený a chyba je zapísaná na štandardný chybový výstup.\\
			\hline
	\caption{Use case : Reťazie príkazov}
	\label{table:1}

	\end{longtable}
\end{center}


\paragraph{Manažovať balíčky}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}

			\hline
			\textbf{Use case} & Manažovať balíčky \\ 
			\hline
			\textbf{Podmienky} & Shell aplikácia musí byť spustená.\\ 
			\hline
			\textbf{Vstup} & Textový reťazec obsahujúci príkaz pkg a jeho argumenty.\\
			\hline
			\textbf{Popis} & Používateľ bude schopný nahrať, zmazať, nahradiť vybraný balíček. \\ 
			\hline
			\textbf{Výstup} & Textový reťazec, ktorý sa v závislosti od programu mení v dĺžke a obsahu .\\
			\hline
			\textbf{Chyba} & O chybe je používateľ oboznámený a chyba je zapísaná na štandardný chybový výstup.\\
			\hline
	\caption{Use case : Manažovať balíčky}
	\label{table:1}

	\end{longtable}
\end{center}
\paragraph{Stiahnuť nový balíček}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
			\hline
			\textbf{Use case} & Stiahnuť nový balíček \\ 
			\hline
			\textbf{Podmienky} & Shell aplikácia musí byť spustená. Príkaz na stiahnutie balíčka musí byť správne zadaný.\\ 
			\hline
			\textbf{Vstup} & Textový reťazec obsahujúci príkaz "pkg download <názov balička s verziou>"\\
			\hline
			\textbf{Popis} & Program ako prvé skontroluje adresár balíčkov, či daný balíček nebol stiahnutý, ak nie stiahne nový balíček. V opačnom prípade medzi aktívne balíčky načíta používateľom zvolený balíček.\\ 
			\hline
			\textbf{Výstup} & Textový reťazec  informujúci o úspešnosti sťahovania. Pre jeho načítanie je potrebný reštart aplikácie.\\
			\hline

			\textbf{Chyba} & Vypíše chybu na štandardný chybový výstup v prípade, že daný balíček na servery neexistuje, používateľ nemá internetové pripojenie.\\
			\hline
		\caption{Use case : Stiahnúť nový balíček}
		\label{table:1}
		
	\end{longtable}
\end{center}

\paragraph{Zmeniť  použitý balíček}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		
			\hline
			\textbf{Use case} & Zmeniť  použitý balíček \\ 
			\hline
			\textbf{Podmienky} & Shell aplikácia musí byť spustená. Príkaz na zmenu používaného balíčka musí byť správne zadaný.\\ 
			\hline
			\textbf{Vstup} & Textový reťazec obsahujúci príkaz "pkg change  <názov nahradzujúceho balíčka s verziou>\\
			\hline
			\textbf{Popis} & Program zmení používaný balíček z aktuálne používaného na balíček vybratý používateľom. Táto voľba je aplikovateľná iba pre spravovanie verzií existujúcich balíčkov. V prípade, že nahradzujúci balíček nie je dostupný lokálne, používateľ bude vyzvaný stiahnúť daný balíček.\\ 
			\hline
			\textbf{Výstup} & Textový reťazec informujúci o úspešnosti výmeny, alebo informujúci o potrebe stiahnutia balíčka.\\
			\hline
			\textbf{Chyba} & V prípade ak dôjde počas zmeny balíčkov ku chybe, bude zapísaná na štandardný chybový výstup.\\
			\hline
		\caption{Use case : Zmeniť  použiťý balíček}
		\label{table:1}
		
	\end{longtable}
\end{center}

\paragraph{Zmazať vybraný balíček}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		
			\hline
			\textbf{Use case} & Zmazať vybraný balíček \\ 
			\hline
			\textbf{Vstup} & Textový reťazec obsahujúci príkaz "pkg delete <názov balíčka>.\\
			\hline
			\textbf{Podmienky} & Shell aplikácia musí byť spustená. Príkaz na zmazanie vybraného balíčka musí byť správne zadaný.\\ 
			\hline
			\textbf{Popis} & Program zmaže používateľom vybraný balíček z aktívnych balíčkov a následne ho fyzicky zmaže z disku. \\
			\hline

			\textbf{Výstup} & Textový reťazec informujúci o úspešnosti zmazania zadaného balíčka\\
			\hline
			\textbf{Chyba} & V prípade nesprávneho odstránenia balíčka z aktívnych balíčkov alebo pri následnom zmazaní zo súborového systému bude informácia o chybe presmerovaná na štandardný chybový výstup.\\
			\hline
		\caption{Use case : Zmazať vybraný balíček}
		\label{table:1}
		
	\end{longtable}
\end{center}
\paragraph{Získať systémové informácie}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		
			\hline
			\textbf{Use case} & Získať systémové informácie \\ 
			\hline
			\textbf{Vstup} & Vstupom je textový reťazec "sysinfo".\\
			\hline
			\textbf{Podmienky} & Shell aplikácia musí byť spustená. Používateľ vloží platný príkaz na vyžiadanie systémových informácií. \\ 
			\hline
			\textbf{Popis} & Program vypíše na štandardný výstup informácie o využití systémových zdrojov,  ako napríklad využitie procesora, využitie pamäte RAM, využitie oddielu swap a podobne.\\ 
			\hline
					
			\textbf{Výstup} & Výstupom je textový reťazec, formátovaný do riadkov. Každému riadku prislúcha jedna informácia, napr. CPU, ďalší riadok RAM atď.. V prípade viac jadrového procesora sa vypíšu informácie o každom z jadier.  \\
			\hline
			\textbf{Chyba} & V prípade, že používateľ nemá právo na získanie informácií, program vypíše dôvod priamo na štandardný výstup. Rovnako program vypíše aj akékoľvek chyby, ku ktorým môže dôjsť počas behu.\\
			\hline
		\caption{Use case : Získať systémové informácie}
		\label{table:1}
		
	\end{longtable}
\end{center}

\paragraph{Získať informácie o procesoch}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		
			\hline
			\textbf{Use case} & Získať informácie o procesoch \\ 
			\hline
			\textbf{Vstup} & Vstupom je textový reťazec "processes".\\
			\hline
			\textbf{Podmienky} & Shell aplikácia musí byť spustená. Používateľ vloží platný príkaz na vyžiadanie informácií o procesoch. \\ 
			\hline

			\textbf{Popis} & Program vypíše na štandardný výstup informácie o spustených procesoch, používateľoch, ktorí tieto procesy spúšťajú, koľko percent procesoru, pamäte RAM používajú.\\ 
			\hline

			\textbf{Výstup} & Výstupom je prehľadný výpis v podobe tabuľky, kde každý riadok zodpovedá jednému procesu. Nad jednotlivými hodnotami je hlavný riadok, ktorý popisuje o akú hodnotu ide.\\
			\hline
			\textbf{Chyba} & V prípade, že nie je možné získať informácie o procesoch, je táto skutočnosť zobrazená na stdout a popis chyby sa presmeruje na štandardný chybový výstup.\\
			\hline
		\caption{Use case : Získať informácie o procesoch}
		\label{table:1}
		
	\end{longtable}
\end{center}
\paragraph{Vytvoriť skript}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		
			\hline
			\textbf{Use case} & Vytvoriť skript \\ 
			\hline
			\textbf{Podmienky} & Používateľ musí mať prístup k akémukoľvek textovému editoru.  \\ 
			\hline
			\textbf{Vstup} & Vstupom musí byť správne napísaný skript. \\
			\hline
			\textbf{Popis} & Používateľ napíše skrip, ktorý bude prečítaný programom a vykonaný.\\ 
			\hline
			\textbf{Výstup} & Skrip vráti výstup svojho beho buď na štandardný výstup, alebo do súboru, v závislosti od toho ako je naimplementovaný.\\
			\hline
			\textbf{Chyba} & V prípade, že dôjde k menšej chybe, informácia bude zobrazená používateľovi, resp. presmerovaná do súboru.\\
			\hline
		\caption{Use case : Vytvoriť skript}
		\label{table:1}
		
	\end{longtable}
\end{center}
\paragraph{Vytvoriť funkciu}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		
			\hline
			\textbf{Use case} & Vytvoriť funkciu \\ 
			\hline
			\textbf{Podmienky} & Používateľ musí mať prístup k akémukoľvek textovému editoru.  \\ 
			\hline
			\textbf{Vstup} & Funkcia musí byť správne zadefinovaná. 
			Syntax pre definovanie funkcie : 
			\newline
			function <návratový typ> <názov funkcie>(parametre funkcie){telo funkcie}. \\
			\hline
			
			\textbf{Popis} & Používateľ napíše funkciu, ktorá bude prečítaná programom a vykonaná.\\ 
			\hline

			\textbf{Výstup} & Funkcia vracia premennú s definovanou návratovou hodnotou.\\
			\hline
			\textbf{Chyba} & V prípade, že nastane chyba pri exekúcii funkcie, program skončí a zapíše informácie o chybe na štandardný chybový výstup.\\
			\hline
		\caption{Use case : Vytvoriť funkciu}
		\label{table:1}
		
	\end{longtable}
\end{center}
\paragraph{Override funkcie}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		
			\hline
			\textbf{Use case} & Override funkcie \\ 
			\hline
			\textbf{Podmienky} & Používateľ musí mať prístup k akémukoľvek textovému editoru.  \\ 
			\hline
			\textbf{Vstup} & Nad funkciou je potrebné zapísať @Override,  čo prekladaču povie, že má používať práve túto verziu funkcie.\\
			\hline
			
			\textbf{Popis} & Používateľ napíše funkciu, ktorá bude prečítaná programom a vykonaná. Navyše bude nahrádzať funkciu s rovnakým názvom.\\ 
			\hline
			\textbf{Výstup} & Premenná, ktorá je uvedená v definícii funkcie.\\
			\hline
			\textbf{Chyba} & V prípade zle zadefinovanej syntaxe je problém zapísaný na štandardný chybový výstup a vykonávanie skriptu je ukončené.\\
			\hline
		\caption{Use case : Override funkcie}
		\label{table:1}
		
	\end{longtable}
\end{center}
\paragraph{Vytvoriť cyklus}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		
			\hline
			\textbf{Use case} & Vytvoriť cyklus \\ 
			\hline
			\textbf{Podmienky} & Používateľ musí mať prístup k akémukoľvek textovému editoru.  \\ 
			\hline
			\textbf{Vstup} & Cyklus musí byť správne zadefinovaný. 
			Syntax pre definovanie funkcie : 
			\newline
			for(<inicializácia premennej>;<podmienka pre spustenie>;<inkrement>){telo cyklu obsahujúce volania funkcií, príkazy, atď..}. \\
			\hline

			\textbf{Popis} & Používateľ napíše cyklus, ktorý bude prečítaný programom a vykonaná sa.\\ 
			\hline
			\textbf{Výstup} & Cyklus nemá žiadny výstup.\\
			\hline
			\textbf{Chyba} & V prípade, že nastane chyba pri parsovaní alebo exekúcii cyklu, program skončí a zapíše informácie o chybe na štandardný chybový výstup.\\
			\hline
		\caption{Use case : Vytvoriť cyklus}
		\label{table:1}
		
	\end{longtable}
\end{center}
\paragraph{Vytvoriť podmienku}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		
			\hline
			\textbf{Use case} & Vytvoriť podmienku \\ 
			\hline
			\textbf{Podmienky} & Používateľ musí mať prístup k akémukoľvek textovému editoru.  \\ 
			\hline
			\textbf{Vstup} & Podmienka musí byť správne zadefinovaná. 
			Syntax pre definovanie podmienky : 
			\newline
			if(boolean value){telo podmienky obsahujúce volania funkcií, príkazy, atď..}. \\
			\hline
			\textbf{Popis} & Používateľ napíše podmienku, ktorá bude prečítaná programom a zohľadnená počas behu skriptu.\\ 
			\hline
			\textbf{Výstup} & Podmienka nemá žiadny výstup.\\
			\hline
			\textbf{Chyba} & V prípade, že nastane chyba pri parsovaní alebo exekúcii podmienky, program skončí a zapíše informácie o chybe na štandardný chybový výstup.\\
			\hline
		\caption{Use case : Vytvoriť podmienku}
		\label{table:1}
		
	\end{longtable}
\end{center}
\paragraph{Vytvoriť premenné}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		
			\hline
			\textbf{Use case} & Vytvoriť premenné \\ 
			\hline
			\textbf{Podmienky} & Používateľ musí mať prístup k akémukoľvek textovému editoru.  \\ 
			\hline
			\textbf{Vstup} & Premenná musí byť správne zadefinovaná. 
			\newline
			Syntax pre definovanie premennej : 
			\newline
			<typ> <názov premennej>; alebo 
			\newline
			 <typ> <názov premennej> = <hodnota>;
			 \newline
			 , kde hodnota môže byť konkrétna hodnota alebo iná premenná rovnakého typu.\\
			\hline
			\textbf{Popis} & Používateľ napíše inicializáciu alebo definíciu premennej, ktorá bude prečítaná programom a vykonaná.\\ 
			\hline
			\textbf{Výstup} & Program si uloží premmenú a jej hodnotu, ak bola definovaná.\\
			\hline
			\textbf{Chyba} & V prípade, že nastane chyba, používateľ bude informovaný o neúspechu na štandardný chybový výstup.\\
			\hline
			\caption{Use case : Vytvoriť premenné}
		\label{table:1}
	
	\end{longtable}
\end{center}
\paragraph{Vykonať základné aritmetické operácie}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		
			\hline
			\textbf{Use case} & Vykonať základné aritmetické operácie \\ 
			\hline
			\textbf{Podmienky} & Používateľ musí mať prístup k akémukoľvek textovému editoru.  \\ 
			\hline
			\textbf{Vstup} & Premenná musí byť správne zadefinovaná. 
			\newline
			Syntax pre definovanie /zmenu hodnoty premennej: 
			\newline
			<názov premennej> = <výraz>; alebo 
			\newline
			<typ> <názov premennej> = <výraz>;
			\newline
			, kde výraz môže byť operácia nad číselnými hodnotami a číselnými premennými. \\
			\hline
			\textbf{Popis} & Používateľ napíše príkaz, ktorý bude prečítaný programom a vykonaný.\\ 
			\hline
			\textbf{Výstup} & Príkaz nastaví hodnotu premennej s vypočítanou návratovou hodnotou.\\
			\hline
			\textbf{Chyba} & V prípade, že nastane chyba pri exekúcii príkazu, program skončí a zapíše informácie o chybe na štandardný chybový výstup.\\
			\hline
		\caption{Use case : Vytvoriť funkciu}
		\label{table:1}
		
	\end{longtable}
\end{center}
\paragraph{Vykonať základné logické operácie}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		
			\hline
			\textbf{Use case} & Vykonať základné logické operácie\\ 
			\hline
			\textbf{Podmienky} & Používateľ musí mať prístup k akémukoľvek textovému editoru.  \\ 
			\hline
			\textbf{Vstup} & Premenná musí byť správne zadefinovaná. \newline
			Syntax pre definovanie /zmenu hodnoty premennej:  \newline
			<názov premennej> = <výraz>; alebo \newline
			<typ> <názov premennej> = <výraz>;
			\newline
			, kde výraz môže byť operácia nad číselnými hodnotami, číselnými premennými, ako aj nad pravdivostnými.\newline
			Vzťahy medzi číselnými hodnotami musia byť definované logickými operátormi - <, >, <=, >=, ==, !=.\newline
			Vzťahy medzi pravdivostnými hodnotami musia byť definované logickými operátormi : ==, !=, ||, \&\&.  \\
			\hline
			\textbf{Popis} & Používateľ napíše príkaz, ktorý bude prečítaný programom a vykonaný.\\ 
			\hline
			\textbf{Výstup} & Príkaz nastaví hodnotu premennej s vypočítanou návratovou hodnotou.\\
			\hline
			\textbf{Chyba} & V prípade, že nastane chyba pri exekúcii príkazu, program skončí a zapíše informácie o chybe na štandardný chybový výstup.\\
			\hline
		\caption{Use case : Vytvoriť funkciu}
		\label{table:1}
		
	\end{longtable}
\end{center}

\paragraph{Presmerovať chybový výstup}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		
			\hline
			\textbf{Use case} & Presmerovať chybový výstup \\ 
			\hline
			\textbf{Vstup} & Pre presmerovanie na chybový výstup je potrebné dodržať syntax command stderr> file\\
			\hline
			\textbf{Podmienky} & Shell aplikácia musí byť spustená. Používateľ vloží platný príkaz na presmerovanie chybového výstupu. \\ 
			\hline
			\textbf{Popis} & Program presmeruje chybový výstup tam, kam mu používateľ v príkaze zadefinuje. \\ 
			\hline
			\textbf{Výstup} & Výstup programu predstavuje textový reťazec s popisom chyby, ktorá nastala.\\
			\hline
			\textbf{Chyba} & Ak by došlo ku chybe, chyba sa zapíše sa do logu aplikácie.\\
			\hline
		\caption{Use case : Presmerovať chybový výstup}
		\label{table:1}
		
	\end{longtable}
\end{center}
\paragraph{Presmerovať štandardný výstup}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		
			\hline
			\textbf{Use case} & Presmerovať štandardný výstup \\ 
			\hline
			\textbf{Podmienky} & Shell aplikácia musí byť spustená. Používateľ vloží platný príkaz na presmerovanie štandardného výstupu. \\ 
			\hline
			\textbf{Vstup} & Pre presmerovanie na štandardný výstup je potrebné dodržať syntax command stdout> file\\
			\hline
			\textbf{Popis} & Program presmeruje štandardný výstup tam, kam mu používateľ v príkaze zadefinuje.\\ 
			\hline
			\textbf{Výstup} & Výstup programu predstavuje textový reťazec s výstupom zo skriptu alebo príkazu.\\
			\hline
			\textbf{Chyba} & Ak by došlo ku chybe, chyba sa zapíše sa do logu aplikácie.\\
			\hline
		\caption{Use case : Presmerovať štandardný výstup }
		\label{table:1}
		
	\end{longtable}
\end{center}



\subsubsection{Vývojár balíčkov}
\indent Vychádzajúc z názvu role je zjavné, že tento hráč sa bude starať o vývoj aplikácie a jej funkcionalitu v zmysle rozširovania API, ktoré môže vývojár skriptov používať pre efektívnejšiu prácu.
\paragraph{Implementovať vlastný balíček}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		
			\hline
			\textbf{Use case} & Implementovať vlastný balíček \\ 
			\hline
			\textbf{Podmienky} & Používateľ musí mať nainštalovanú Java SDK vo verzii 8, mať prístup k textovému editoru.  \\ 
			\hline
			\textbf{Vstup} & Balíček obsahujúci všetky potrebné rozhrania, ktoré musí vývojár balíčka implementovať.\\
			\hline
			\textbf{Popis} & Používateľ implementuje novú funkcionalitu v Jave, následne všetky zdrojové súbory skompiluje a pridá do \acrshort{jar} súboru určeného na ukladanie nových balíčkov.\\ 
			\hline
			\textbf{Výstup} & Balíček, ktorý je možné nahrať do aplikácie a používať ako jeden z príkazov.\\
			\hline
			\textbf{Chyba} & Chyba môže nastať pri vytváraní balíčka, kedy vývojára o chybe informuje prekladač jazyka, v ktorom je balíček implementovaný. V prípade neúspešného načítania je používateľ informovaný priamo v konzole na štandardný výstup.\\
			\hline
		\caption{Use case : Implementovať vlastný balíček}
		\label{table:1}
		
	\end{longtable}
\end{center}

\paragraph{Upravovať existujúce balíčky}
\begin{center}
	\begin{longtable}{|p{2.5cm}|p{12.2cm}|}
		
			\hline
			\textbf{Use case} & Upravovať existujúce balíčky \\ 
			\hline
			\textbf{Podmienky} &  Používateľ musí mať nainštalovanú Java SDK vo verzii 8, mať prístup k textovému editoru.  \\ 
			\hline
			\textbf{Vstup} & Zdrojové súbory už existujúceho balíčka.\\
			\hline
			\textbf{Popis} & Používateľ upraví implementáciu alebo pridá novú funkcionalitu v Jave, následne všetky zdrojové súbory skompiluje a pridá do \acrshort{jar} súboru určeného na ukladanie nových balíčkov\\ 
			\hline
			\textbf{Výstup} & Po úprave je balíček možné nahrať do aplikácie a používať ako jeden z príkazov.\\
			\hline
			\textbf{Chyba} & Chyba môže nastať pri vytváraní balíčka, kedy vývojára o chybe informuje prekladač jazyka, v ktorom je balíček implementovaný. V prípade neúspešného načítania je používateľ informovaný priamo v konzole na štandardný výstup.\\
			\hline
		\caption{Use case : Upravovať existujúce balíčky}
		\label{table:1}
		
	\end{longtable}
\end{center}
\subsection{Výber programovacieho jazyka}
\indent Java je programovací jazyk a výpočtová platforma, ktorá bola vydaná spoločnosťou Sun Microsystems v roku 1995. \cite{java} 
Programy v Jave sú prvotne preložené do tzv. byte-code, ktorý je rovnaký pre všetky \acrshort{pc}. Pomocou jednoduchého programu je byte-code preložený do jazyka, ktorému rozumie konrétny \acrshort{pc}.
Java je objektovo-orientovaný programovací jazyk, čo znamená že rovnako ako v živote, aj v Jave je všetko tvorené objektami. Obsahuje široké spektrum knižníc, ktoré slúžia nielen na vývoj webových, ale aj desktopových aplikácií.
Podporuje multitrading, čo umožňuje vytvárať efektívne programy pre počítače s viacjadrovým procesorom.\cite{javabook}
\subsection{Návrhové vzory}
\indent Návrhové vzory sú všeobecne opakovaným riešním pre všeobecne opakujúci sa problém pri dizajnovaní softwéru. Návrhový vzor nie je nemenný dizajn, vždy je potrebné aby si ho programátori uspôsobili podľa vlstných potrieb. Návrhové vzory sa delia do troch základných skupín vytváracie vzory, štrukturálne vzory a vzory správania. 

\subsubsection{Factory - továreň}
\indent Factory návrhový vzor patrí do sekcie vytváracích vzorov, pomocou tohoto vzoru budeme schopný vytvárať objekty bez toho aby sme prezradili logiku ich vytvárania klientovi.
Diagram návrhového vzoru je mozné vidieť na nasledujúcom obrázku.
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=10cm]{img/factory_design_pattern.jpg}
	\caption{Class diagram Factory návrhového vzoru}
	\label{fig:test}
\end{figure}
\newline
\subsubsection{Command - príkaz}
\indent Command pattern je známy behaviorálny návrhový vzor, používa sa najmä na menežovanie algoritmov, vzťahov a zodpovednosti medzi objektami. 
Cieľom vzoru je zapúzdriť požiadavku(request) ako objekt tým pádom parametrizovať klienta s rôznymi požiadavkami a zabezpečiť operáciu spať.
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=10cm]{img/command_pattern_class.jpg}
	\caption{Class diagram Command návrhového vzoru}
	\label{fig:test}
\end{figure}
\newline
Command vzor deklaruje rozhranie pre všetky budúce commandy a zároveň execute() metódu, ktorú s vypýta Receiver commandu aby splnil požadovanú operáciu.
Receiver je objekt, ktorý vie ako požadovanú operáciu splniť. Invoker pozná command a pomocou implementovanej execute() metódy dokáže vyvolať požadovanú operáciu.
Klient potrebuje implemenotvaž ConcreteCommand a nastavit Receiver pre command. ConcreteCommand definuje spojenie medzi action a receiver. Keď Invoker zavolá execute() metódu na ConcreteCommand spustí tým jednu alebo viac akcií, ktoré budú bežať pomocou Receivera.

Pre lepšie pochopenie je proces zobrazený aj na sekvenčnom diagrame.
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=10cm]{img/command_seq.jpg}
	\caption{Sekvenčný diagram Command návrhového vzoru}
	\label{fig:test}
\end{figure}
\newline

\subsection{Aplikácia}
\indent Pre implementáciu vlastného riešenia bolo potrebné na základe prípadov použitia identifikovať časti, z ktorých bude aplikácia pozostávať. Naším zámerom nebolo vytvorenie jednej veľkej aplikácie, ktorá by sa mohla časom stať neudržiavateľnou, ale aplikácia, ktorá umožní používateľom interaktívny aj skriptovací módus. Rozhodli sme sa, že navrhneme jednu hlavnú aplikáciu, ktorá bude mať na starosti interaktívny prístup pre používateľa rovnako aj skriptovací módus, avšak funkcionality, ktoré bude podporovať, zabezpečia menšie externé podprogrami - pluginy, ktoré sa do apikácie nahrajú pri štarte. Pre dosiahnutie požadovaných výsledkov použijeme návrhový vzor Command. Ako ďalšie sme definovali komponenty aplikácie.

\subsection{Komponenty aplikácie}
\indent Po vybratí návrhového vzoru sme prešli na identifikáciu komponentov aplikácie. V prvom návrhu sme identifikovali niekoľko komponentov, ktoré považujeme za podstatné a potrebné pre správny chod programu. Z týchto komponentov sme následne vytvorili malý projekt, kde sme sa pokúsili vytvoriť niekoľko pluginov implementovaných pomocou command dizajnového návrhu na demonštrovanie funkčnosti. Nakoľko bol model funkčný, rozhodli sme sa pokračovať s jeho vývojom. Uvádzame aj komponenty, ktoré sme identifikovali pri vytváraní tejto ukážky funkčnosti : 
\begin{itemize}
	\item Parser - vstupov aj výstupov,
	\item Loader - na nahrávanie  \acrshort{jar} súborov,
	\item Sťahovač závislostí - \acrshort{jar} súbory, ktoré momentálne produkt neobsahuje napr. vlastné riešenia,
	\item Scope - je oblasť kde sa definujú premenné, funkcie a pod., tento komponent slúži na vytváranie scopov v rámci aplikácie,
	\item ScopeData - ktoré majú slúžiť na udržovanie dát v jednotlivých scopoch,
	\item ShellPlugin - komponent, ktorý nesie implementáciu príkazov.
\end{itemize}

 \begin{figure}[!htbp]
	\centering
	\includegraphics[width=\linewidth]{img/first_attemp_class_diag.jpg}
	\caption{Pvrvé funkčné riešenie}
	\label{fig:test}
\end{figure}
\newline
\subsection{Plugin}
\indent Z nasledovného diagramu tried nebolo na prvý pohľad zjavné aké komponenty v programe existujú, preto bolo potrebné tieto komponenty rozumne rodeliť. Z prvotného návrhu sme vytiahli plugin, ktorý bude slúžiť na nahrávanie nových funkcionalít do programu.  Diagram implementácie rozhraní a konkrétnych tried  je viditeľný na nasledovnom obrázku. 
\newpage
 \begin{figure}[!htbp]
	\centering
	\includegraphics[width=\linewidth]{img/plugin_class.jpg}
	\caption{Plugin - diagram tried}
	\label{fig:test}
\end{figure}
\newline
\indent Ako vidieť z diagramu, Plugin pozostáva z nasledovných častí :
\begin{itemize}
	\item ShellPlugin - je rozhranie, ktoré slúži na získavanie inštancií commandu, ako aj informáciách o plugine, 
	\item Command - rozhranie, slúžiace na komunikáciu s receivermi,
	\item Receiver - triedy, ktoré implementujú receiver špecifikujú funkcionalitu pluginu,
	\item CommandParser - obsahuje parser vstupov,
	\item CommandOutput - rozhranie pre výstupy z commandu,
	\item CommandInput - rozhranie pre vstupy z commandu,
	\item  PluginMeta - nesie základné informácie o plugine.
\end{itemize}
Aj keď náš prvotý program fungoval správne čakali sme, že počas vývoja ešte môže dôjsť k obmenám tried a rozhraní, nakoľko málokedy sa podarí odhadnúť  všetky kľúčové časti už počas návrhu.

\newpage
\subsection{Diagram tried aplikácie}
 \begin{figure}[!htbp]
	\centering
	\includegraphics[scale=0.4]{img/ClassApplication.jpg}
	\caption{Diagram tried aplikácie}
	\label{fig:test}
\end{figure}
\subsubsection{Stručný popis tried}
\indent Obrázok 16 zobrazuje diagram tried aplikácie, ktoré v nasledujúcej časti stručne predstavíme.
\paragraph{AbstractScope}
Táto trieda je jednou z najhlavnejších celého programu, tvorí základný pilier pre tvorbu akýchkoľvek scopov aplikácie, beh skriptov a pochopiteľne príkazov v interaktívnom móde. Obsahuje informácie o všetkých pluginoch, ktoré sa nahrali pri štarte aplikácie, názov scopu a inštanciu exekútora, pomocou ktorého sa vykonávajú všetky operácie v aplikácii. Trieda má tiež informácie o vstupných parametroch, výstupných hodnotách a funkciách, ktoré sú v danom scope definované. Spomenuté hodnoty sa využívajú pri vytváraní a behu skriptov. Implementuje rozhrania Scope, Runnable. Implementuje metódy run() pre zabezpečenie interaktívneho módu, kde sa však môžu spúšťať aj skripty. Tiež implementuje metódu executeScript(String function, ScopeVariables scopeVariables), ktorá slúži na rekurzívne volanie funkcií v skriptovacom móde a  spúšťanie ich príkazov.
\paragraph{ScopeImpl}
Je prvá neabstraktná trieda, ktorá dedí od triedy AbstractScope, a slúži na inštanciáciu tejto triedy. 
\paragraph{ExecutorImpl}
Trieda ExecutorImpl implementuje rozhranie Executor, a teda aj jeho triedu CommandIO execute(String command, Scope scope). Vstupom do tejto metódy je príkaz od používateľa a scope v ktorom ho chce vykonať. Definovanie scopu nám slúži na informovanie jednotlivých prijímačov(Reciever), kde sa má daný príkaz vykonať. Ak by scope nebol presne definovaný, aplikácia by sa nevedela rozhodnúť kde sa majú príkazy premietnuť a vyhodila by chybu.
\paragraph{RootParser}
RootParser je najpodstatnejšia trieda pre skriptovací mód. Jej úlohou je načítať zdrojové súbory skriptu a následne spustiť exekúciu, ak parsovanie prebehlo v poriadku.
\paragraph{PluginFactory}
PluginFactory, ako z jej názvu vyplýva, je továreň, do ktorej sa pri štarte aplikácie nahrávajú všetky pluginy dostupné z disku. Na získavanie dostupných pluginov sa používa trieda JarLoader. 
\paragraph{JarLoader}
JarLoade je trieda, ktorá pomocou class loadera nahráva nové pluginy do aplikácie.
\section{Implementácia}
\indent V tejto kapitole sa budeme venovať konkrétnemu riešeniu daného problému. Kapitola nás postupne prevedie cez jednotlivé kroky implementácie riešenia. Každý krok budeme popisovať jednou z nasledovných možností alebo kombináciou : pomocou diagramu aktivít, diagramu tried, pseudokódom prípadne útržkami zdrojového kódu z fungujúcej aplikácie. Jednotlivé sekcie práce sme rodelili na základe toho akými smermi sa môže aplikácia uberať. Na nasledovnom obrázku je zobrazená aktivita spustenia konzoly. Ako vidieť z diagramu aplikácia sa najprv nainicializuje, čo to znamená si povieme v sekcii 4.1. V ďalšom kroku zistí či má na vstupe parametre. V prípade, že áno vykoná ich, inak spustí konzolu, ktorá čaká na vstup od používateľa. V tejto časti si popíšeme čo sa deje v prvom prípade a teda, že máme zadané parametre. 
\newline 
\indent Možnosť s parametrami na vstupe sme potrebovali implementovať kvôli tomu aby sa dala aplikácia integrovať s inými enterprise aplikáciami. Tie môžu buď čítať výstupy priamo z konzoly alebo si ich môžu presmerovať do súboru. Novo vytvorený súbor si následne môžu načítať a vykonať nad ním potrebné operácie.
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=\linewidth]{img/System.jpg}
	\caption{Activita spustenia aplikácie}
	\label{fig:test}
\end{figure}
\subsection{Inicializácia aplikácie}
\indent Inicializácia pozostáva z dvoch krokov :
\begin{itemize}
	\item Nahranie dostupných pluginov z disku,
	\item Získanie inštancie exekútora - ExecutorImpl.
\end{itemize}
\begin{figure}[!htbp]
	\centering
	\includegraphics[width=\linewidth]{img/initialization.jpg}
	\caption{Activita spustenia aplikácie}
	\label{fig:test}
\end{figure}
\subsubsection{Nahrávanie pluginov}
\indent Nahrávanie pluginov má na starosti trieda PluginFactory a JarLoader, proces nahratia pozostáva z troch krokov.\newline
\paragraph{Načítanie dostupých pluginov z disku} Trieda PluginFactory zavolá metódu registerAllPlugins(), ktorá najprv získa cesty k uloženým jar súborom, ktoré musia byť uložene na presne špecifikovanom mieste. Následne tieto cesty odovzdá triede JarLoader, ktorá sa pokúsi na daných cestách načítať \acrshort{jar} súbory, nájsť v nich triedu implementujúcu rozhranie ShellPlugin. Ak takúto triedu nájde pokúsi sa z nej vytvoriť inštanciu pomocou reflexie a takto vytvorenú inštanciu následne vracia triede PluginFactory, ktorá si túto triedu uloží na základe informácií, ktoré každý ShellPlugin poskytuje. PluginFactory ukladá inštancie do mapy kde kľúč je trieda PluginMeta získaná z pluginu, a hodnotou je práve načítaný plugin. 
\begin{algorithm}
	\begin{minted}[]{java}
try {
 URLClassLoader cl = URLClassLoader.newInstance(urls);
 JarInputStream jarFile = new JarInputStream(new FileInputStream(jarPath
 .toFile()));
   while (true) {
   jarEntry = jarFile.getNextJarEntry();
   if (jarEntry == null) {
     break;
   }
   if (jarEntry.getName().endsWith(".class")) {
     String className = jarEntry.getName()
     .substring(0, jarEntry.getName().length() - 6);
     className = className.replace('/', '.');
     Class c = cl.loadClass(className);
     Object obj = c.newInstance();
     if (obj instanceof ShellPlugin) {
       return Optional.of((ShellPlugin) obj);
     }
   }
}

	\end{minted}
	\caption{Ukážka loadovania balíčka z disku počítača}
	\label{alg:gen}
\end{algorithm}
\paragraph{Načítanie dostupých pluginov z aplikácie}
\indent Pluginy môžu byť definované priamov a plikácii. V tomto prípade priamo do rovnakej mapy ako v predchádzajúcom prípade vkladáme inštancie pluginov a informáciách o nich. 
\paragraph{Finálne načítanie pluginov}
\indent Používateľ môže počas využívania aplikácie, stiahnuť alebo naprogramovať viaceré verzie rovnakého pluginu. Z tohoto dôvodu sme naimplementovali  krok, ktorý má za úlohu načítať všetky balíčky s jedinečným menom a najvyššou možnou verziou pre daný balíček. Následne načítanie končí a vráti sa inštancia tejto továrne pre pluginy.
\section{Zhodnotenie výsledkov}
Zatiaľ sa toho nespravilo hodne ale verím, že sa to tu cele zaplní.